OutOfMemoryError  是异常还是error
是error, 是系统捕捉处理的，不是由应用程序捕捉助理的


--- ---  spring默认单例，如何解决并发问题的
虽然spring对象是单例的，但类里面方法对每个线程来说都是独立运行的，不存在多线程问题，
只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构，不知道你现在明白没。

总结， 单例和多线程没有关系，只是单例里面的变量有多线程问题，ThreadLocal

spring中的bean默认是单例的，通常对单例进行多线程访问时，为了线程安全而采用同步机制，以时间换空间的方式，
而Spring中是利用ThreadLocal来以空间换取时间，为每一个线程提供变量副本，来保证变量副本对于某一线程都是线程安全的

--- ---  AOP 是怎么实现的
答： 动态代理，修改class字节码
JDK 基於接口的動態代理
cglib 基於類的動態代理

AOP是Aspect Oriented Programming的缩写，意思是面向切面编程.与OOP(Object Oriented Programming)面向对象编程对等,都是一种编程思想.
从OOP角度分析,我们关注业务的处理逻辑,是属于纵向的行为,从AOP角度分析,我们关注对象行为发生时的问题，是属于横向的问题.
AOP就是把贯穿在各个模块之间相同的功能抽取出来，然后封装成一个面.
AOP的作用: 1.监控函数的调用 2.捕获异常的发生
实际应用于:事务,安全,日志等横切关注

两种方式实现AOP的方式:
1.JDK提供的动态代理实现,Spring规定对于有接口的类用JDK,对于无接口和抽象类使用cglib,
  虽然cglib均可代理，但是cglib复杂，效率低，而且cglib中代理的类中不能有final的方法.
2.其中对于AOP来说,他也可以理解为一个面，在这个面里面我们利用代理类来找目标对象是什么,拦截那些方法,然后在这些方法的前后也可以执行一些操作.

--- ---  IOC(Inversion of control):控制反转,依赖注入
概念:控制权有对象本身专享容器,由容器根据配置文件去创建实例,并创建各个实例之间的关系,
则通俗的说，对象的创建再也不需要程序员来管理,而是可以有spring容器来进行创建和销毁,我们只需要关注业务逻辑.
依赖IOC容器并管理bean,有两种,一种是BeanFactory,另一种是ApplicationContext,但是APPlicationContext extends BeanFactory.


--- ---   java 動態代理
java 的動態代理是如何實現的
是通過接口的動態代理



Proxy(Class)
Proxy这个类的作用就是用来动态创建一个代理对象的类
InvocationHandler(Interface)
每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，
当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用

實現接口InvocationHandler，負責方法調用處理
利用Proxy創建代理類 （運行時生成靜態代理）
通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，
而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。
**********有生成的動態代理源碼**********
https://blog.csdn.net/u012033124/article/details/53645727?utm_source=itdadao&utm_medium=referral



------ Spring Aop的底层原理
java的动态代理或者cglib的动态代理

------ spring怎么选择使用java原生的动态代理还是选用cglib的动态代理呢？
根据到代理的类是否实现了接口，如果有接口默认用原生的动态代理，否则只有选用cglib，关于两者的性能，因为本人没有自己测试过，不敢人云亦云。


------ AOP有规范吗？
AOP是有规范的，叫做AOP联盟，






